'use client'
import React, { useRef, useState, useCallback, useEffect } from 'react'
import type { SketchData, SketchPath } from '@/types/blackboard'
type Tool = 'pen' | 'line' | 'rectangle' | 'circle' | 'eraser'
interface Props { width: number; height: number; sketchData?: SketchData; onSketchChange?: (sketchData: SketchData) => void; readOnly?: boolean }
export function SketchCanvas({ width, height, sketchData, onSketchChange, readOnly = false }: Props) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [isDrawing, setIsDrawing] = useState(false)
  const [tool, setTool] = useState<Tool>('pen')
  const [strokeColor, setStrokeColor] = useState('#ffffff')
  const [strokeWidth] = useState(2)
  const [currentPath, setCurrentPath] = useState<SketchPath | null>(null)
  const [paths, setPaths] = useState<SketchPath[]>(sketchData?.paths || [])
  const [startPoint, setStartPoint] = useState<{x:number;y:number}|null>(null)
  useEffect(() => { if (onSketchChange) onSketchChange({ paths, width, height }) }, [paths, width, height, onSketchChange])
  const redrawCanvas = useCallback(() => { const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); if (!ctx) return; ctx.clearRect(0, 0, width, height); ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0, 0, width, height); paths.forEach(path => { if (path.tool !== 'eraser') { ctx.strokeStyle = path.strokeColor; ctx.lineWidth = path.strokeWidth; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; if (path.tool === 'pen' && path.points.length >= 2) { ctx.beginPath(); ctx.moveTo(path.points[0].x, path.points[0].y); for (let i = 1; i < path.points.length; i++) ctx.lineTo(path.points[i].x, path.points[i].y); ctx.stroke() } else if (path.points.length >= 2) { const s = path.points[0], e = path.points[path.points.length - 1]; ctx.beginPath(); if (path.tool === 'line') { ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y) } else if (path.tool === 'rectangle') ctx.strokeRect(Math.min(s.x, e.x), Math.min(s.y, e.y), Math.abs(e.x - s.x), Math.abs(e.y - s.y)); else if (path.tool === 'circle') ctx.ellipse((s.x + e.x) / 2, (s.y + e.y) / 2, Math.abs(e.x - s.x) / 2, Math.abs(e.y - s.y) / 2, 0, 0, Math.PI * 2); ctx.stroke() } } }); if (currentPath) { ctx.strokeStyle = currentPath.strokeColor; ctx.lineWidth = currentPath.strokeWidth; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; if (currentPath.tool === 'pen' && currentPath.points.length >= 2) { ctx.beginPath(); ctx.moveTo(currentPath.points[0].x, currentPath.points[0].y); for (let i = 1; i < currentPath.points.length; i++) ctx.lineTo(currentPath.points[i].x, currentPath.points[i].y); ctx.stroke() } else if (currentPath.points.length >= 2) { const s = currentPath.points[0], e = currentPath.points[currentPath.points.length - 1]; ctx.beginPath(); if (currentPath.tool === 'line') { ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y) } else if (currentPath.tool === 'rectangle') ctx.strokeRect(Math.min(s.x, e.x), Math.min(s.y, e.y), Math.abs(e.x - s.x), Math.abs(e.y - s.y)); else if (currentPath.tool === 'circle') ctx.ellipse((s.x + e.x) / 2, (s.y + e.y) / 2, Math.abs(e.x - s.x) / 2, Math.abs(e.y - s.y) / 2, 0, 0, Math.PI * 2); ctx.stroke() } } }, [paths, currentPath, width, height])
  useEffect(() => { redrawCanvas() }, [redrawCanvas])
  const getMousePos = (e: React.MouseEvent<HTMLCanvasElement>) => { const canvas = canvasRef.current; if (!canvas) return { x: 0, y: 0 }; const rect = canvas.getBoundingClientRect(); return { x: (e.clientX - rect.left) * width / rect.width, y: (e.clientY - rect.top) * height / rect.height } }
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => { if (readOnly) return; const pos = getMousePos(e); setIsDrawing(true); setStartPoint(pos); if (tool === 'eraser') { const threshold = strokeWidth * 2; setPaths(paths.filter(path => !path.points.some(p => Math.abs(p.x - pos.x) < threshold && Math.abs(p.y - pos.y) < threshold))) } else { setCurrentPath({ id: `path-${Date.now()}`, points: [pos], strokeColor, strokeWidth, tool }) } }
  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => { if (!isDrawing || readOnly) return; const pos = getMousePos(e); if (tool === 'eraser') { const threshold = strokeWidth * 2; setPaths(paths.filter(path => !path.points.some(p => Math.abs(p.x - pos.x) < threshold && Math.abs(p.y - pos.y) < threshold))) } else if (currentPath) { if (tool === 'pen') setCurrentPath({ ...currentPath, points: [...currentPath.points, pos] }); else if (startPoint) setCurrentPath({ ...currentPath, points: [startPoint, pos] }) } }
  const handleMouseUp = () => { if (!isDrawing) return; setIsDrawing(false); if (currentPath && currentPath.points.length > 0) setPaths([...paths, currentPath]); setCurrentPath(null); setStartPoint(null) }
  if (readOnly) return <canvas ref={canvasRef} width={width} height={height} style={{ width: '100%', height: '100%' }} />
  return (<div><div style={{ marginBottom: 8, display: 'flex', gap: 8, flexWrap: 'wrap' }}><div style={{ display: 'flex', gap: 4 }}>{(['pen', 'line', 'rectangle', 'circle', 'eraser'] as Tool[]).map(t => <button key={t} type="button" onClick={() => setTool(t)} style={{ padding: '4px 8px', fontSize: 12, backgroundColor: tool === t ? '#3b82f6' : '#e5e7eb', color: tool === t ? '#fff' : '#374151', border: 'none', borderRadius: 4, cursor: 'pointer' }}>{t}</button>)}</div><div style={{ display: 'flex', gap: 2 }}>{['#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00'].map(color => <button key={color} type="button" onClick={() => setStrokeColor(color)} style={{ width: 24, height: 24, backgroundColor: color, border: strokeColor === color ? '3px solid #000' : '1px solid #ccc', borderRadius: 4, cursor: 'pointer' }} />)}</div><button type="button" onClick={() => setPaths(paths.slice(0, -1))} disabled={paths.length === 0} style={{ padding: '4px 8px', fontSize: 12, backgroundColor: '#f3f4f6', border: '1px solid #d1d5db', borderRadius: 4, cursor: paths.length === 0 ? 'not-allowed' : 'pointer', opacity: paths.length === 0 ? 0.5 : 1 }}>Undo</button><button type="button" onClick={() => setPaths([])} style={{ padding: '4px 8px', fontSize: 12, backgroundColor: '#fee2e2', color: '#991b1b', border: '1px solid #fecaca', borderRadius: 4, cursor: 'pointer' }}>Clear</button></div><canvas ref={canvasRef} width={width} height={height} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} style={{ border: '1px solid #ccc', borderRadius: 4, cursor: 'crosshair', width: '100%', height: 'auto' }} /></div>)
}
export default SketchCanvas
