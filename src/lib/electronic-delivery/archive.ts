/**
 * ZIPアーカイブ生成モジュール
 * 国土交通省 デジタル写真管理情報基準 準拠
 *
 * archiverライブラリを使用して電子納品用ZIPアーカイブを生成します。
 */

import archiver from "archiver";
import { Readable, PassThrough } from "stream";
import type {
  ElectronicDeliveryFolder,
  ExportMetadata,
  ExportProgress,
} from "@/types/electronic-delivery";
import { generatePhotoXml } from "./photo-xml";
import { generateIndexDXml } from "./index-xml";
import { FOLDER_NAMES } from "./folder-structure";

/**
 * アーカイブ設定
 */
export interface ArchiveConfig {
  /** 圧縮レベル (0-9) */
  compressionLevel: number;
  /** コメント */
  comment?: string;
  /** 進捗コールバック */
  onProgress?: (progress: ArchiveProgress) => void;
}

/**
 * アーカイブ進捗情報
 */
export interface ArchiveProgress {
  /** 処理済みファイル数 */
  processedFiles: number;
  /** 総ファイル数 */
  totalFiles: number;
  /** 処理中のファイル名 */
  currentFile?: string;
  /** 処理済みバイト数 */
  processedBytes: number;
  /** 進捗率 (0-100) */
  progressPercent: number;
}

/**
 * アーカイブ結果
 */
export interface ArchiveResult {
  /** 成功かどうか */
  success: boolean;
  /** ZIPデータ (Buffer) */
  buffer?: Buffer;
  /** ファイルサイズ */
  fileSize?: number;
  /** エラーメッセージ */
  error?: string;
  /** 処理時間 (ms) */
  processingTimeMs: number;
  /** 含まれるファイル数 */
  fileCount: number;
}

/**
 * ファイル入力 (バイナリデータまたはURL)
 */
export interface FileInput {
  /** ファイル名 (アーカイブ内のパス) */
  name: string;
  /** ファイルデータ */
  data: Buffer | Uint8Array | string;
  /** ファイル日時 */
  date?: Date;
}

const DEFAULT_CONFIG: ArchiveConfig = {
  compressionLevel: 6,
  comment: "Generated by PhotoManagement - Electronic Delivery Archive",
};

/**
 * 電子納品用ZIPアーカイブを生成する
 * @param folder 電子納品フォルダ構造
 * @param metadata エクスポートメタデータ
 * @param fileContents ファイル内容のマップ (ファイルパス -> データ)
 * @param config アーカイブ設定
 * @returns アーカイブ結果
 */
export async function createDeliveryArchive(
  folder: ElectronicDeliveryFolder,
  metadata: ExportMetadata,
  fileContents: Map<string, Buffer>,
  config: Partial<ArchiveConfig> = {}
): Promise<ArchiveResult> {
  const startTime = Date.now();
  const cfg = { ...DEFAULT_CONFIG, ...config };

  try {
    const files: FileInput[] = [];
    const rootName = folder.rootFolderName;

    // PHOTO.XMLを生成して追加
    const photoXml = generatePhotoXml(folder, metadata);
    files.push({
      name: `${rootName}/${FOLDER_NAMES.PHOTO_XML}`,
      data: photoXml,
      date: new Date(),
    });

    // INDEX_D.XMLを生成して追加
    const indexDXml = generateIndexDXml(metadata);
    files.push({
      name: "INDEX_D.XML",
      data: indexDXml,
      date: new Date(),
    });

    // 写真ファイルを追加
    for (const photoFile of folder.photoFiles) {
      const content = fileContents.get(photoFile.filePath);
      if (content) {
        files.push({
          name: `${rootName}/${FOLDER_NAMES.PIC}/${photoFile.deliveryFileName}`,
          data: content,
          date: new Date(),
        });
      }
    }

    // 参考図ファイルを追加
    for (const drawingFile of folder.drawingFiles) {
      const content = fileContents.get(drawingFile.filePath);
      if (content) {
        files.push({
          name: `${rootName}/${FOLDER_NAMES.DRA}/${drawingFile.deliveryFileName}`,
          data: content,
          date: new Date(),
        });
      }
    }

    // ZIPアーカイブを作成
    const buffer = await createZipArchive(files, cfg);

    return {
      success: true,
      buffer,
      fileSize: buffer.length,
      processingTimeMs: Date.now() - startTime,
      fileCount: files.length,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "不明なエラー",
      processingTimeMs: Date.now() - startTime,
      fileCount: 0,
    };
  }
}

/**
 * ZIPアーカイブを作成する
 * @param files ファイル入力の配列
 * @param config アーカイブ設定
 * @returns ZIPデータのBuffer
 */
export async function createZipArchive(
  files: FileInput[],
  config: Partial<ArchiveConfig> = {}
): Promise<Buffer> {
  const cfg = { ...DEFAULT_CONFIG, ...config };

  return new Promise((resolve, reject) => {
    const archive = archiver("zip", {
      zlib: { level: cfg.compressionLevel },
      comment: cfg.comment,
    });

    const chunks: Buffer[] = [];
    let processedFiles = 0;
    const totalFiles = files.length;

    // エラーハンドリング
    archive.on("error", (err) => {
      reject(err);
    });

    // 警告ハンドリング
    archive.on("warning", (err) => {
      if (err.code === "ENOENT") {
        console.warn("Archive warning:", err.message);
      } else {
        reject(err);
      }
    });

    // データ収集
    archive.on("data", (chunk) => {
      chunks.push(chunk);
    });

    // 完了ハンドリング
    archive.on("end", () => {
      resolve(Buffer.concat(chunks));
    });

    // 進捗コールバック
    archive.on("entry", (entry) => {
      processedFiles++;
      if (cfg.onProgress) {
        cfg.onProgress({
          processedFiles,
          totalFiles,
          currentFile: entry.name,
          processedBytes: archive.pointer(),
          progressPercent: Math.round((processedFiles / totalFiles) * 100),
        });
      }
    });

    // ファイルを追加
    for (const file of files) {
      const data = typeof file.data === "string"
        ? Buffer.from(file.data, "utf-8")
        : Buffer.from(file.data);

      archive.append(data, {
        name: file.name,
        date: file.date || new Date(),
      });
    }

    // アーカイブを完了
    archive.finalize();
  });
}

/**
 * ZIPアーカイブをストリームとして生成する
 * @param files ファイル入力の配列
 * @param config アーカイブ設定
 * @returns 読み取り可能なストリーム
 */
export function createZipArchiveStream(
  files: FileInput[],
  config: Partial<ArchiveConfig> = {}
): Readable {
  const cfg = { ...DEFAULT_CONFIG, ...config };

  const archive = archiver("zip", {
    zlib: { level: cfg.compressionLevel },
    comment: cfg.comment,
  });

  const passThrough = new PassThrough();

  archive.on("error", (err) => {
    passThrough.destroy(err);
  });

  archive.on("warning", (err) => {
    if (err.code !== "ENOENT") {
      passThrough.destroy(err);
    }
  });

  archive.pipe(passThrough);

  // ファイルを追加
  for (const file of files) {
    const data = typeof file.data === "string"
      ? Buffer.from(file.data, "utf-8")
      : Buffer.from(file.data);

    archive.append(data, {
      name: file.name,
      date: file.date || new Date(),
    });
  }

  archive.finalize();

  return passThrough;
}

/**
 * 電子納品フォルダ構造のディレクトリエントリを作成する
 * @param folder 電子納品フォルダ構造
 * @returns ディレクトリエントリ名の配列
 */
export function getDirectoryEntries(folder: ElectronicDeliveryFolder): string[] {
  const directories: string[] = [
    folder.rootFolderName,
    `${folder.rootFolderName}/${FOLDER_NAMES.PIC}`,
  ];

  if (folder.draFolderPath) {
    directories.push(`${folder.rootFolderName}/${FOLDER_NAMES.DRA}`);
  }

  return directories;
}

/**
 * アーカイブのファイルリストを取得する
 * @param folder 電子納品フォルダ構造
 * @returns ファイルパスの配列
 */
export function getArchiveFileList(folder: ElectronicDeliveryFolder): string[] {
  const files: string[] = [];
  const rootName = folder.rootFolderName;

  // INDEX_D.XML
  files.push("INDEX_D.XML");

  // PHOTO.XML
  files.push(`${rootName}/${FOLDER_NAMES.PHOTO_XML}`);

  // 写真ファイル
  for (const photoFile of folder.photoFiles) {
    files.push(`${rootName}/${FOLDER_NAMES.PIC}/${photoFile.deliveryFileName}`);
  }

  // 参考図ファイル
  for (const drawingFile of folder.drawingFiles) {
    files.push(`${rootName}/${FOLDER_NAMES.DRA}/${drawingFile.deliveryFileName}`);
  }

  return files;
}

/**
 * アーカイブのサイズを推定する
 * @param folder 電子納品フォルダ構造
 * @param fileContents ファイル内容のマップ
 * @returns 推定サイズ (バイト)
 */
export function estimateArchiveSize(
  folder: ElectronicDeliveryFolder,
  fileContents: Map<string, Buffer>
): number {
  let totalSize = 0;

  // XMLファイルのサイズ推定 (約10KB)
  totalSize += 10 * 1024;

  // 写真ファイルのサイズ
  for (const photoFile of folder.photoFiles) {
    const content = fileContents.get(photoFile.filePath);
    if (content) {
      // 圧縮率を考慮 (JPEGは既に圧縮されているため、約95%程度)
      totalSize += Math.round(content.length * 0.95);
    }
  }

  // 参考図ファイルのサイズ
  for (const drawingFile of folder.drawingFiles) {
    const content = fileContents.get(drawingFile.filePath);
    if (content) {
      totalSize += Math.round(content.length * 0.95);
    }
  }

  // ZIPヘッダーのオーバーヘッド
  const fileCount = folder.photoFiles.length + folder.drawingFiles.length + 2;
  totalSize += fileCount * 100;

  return totalSize;
}
